

<!DOCTYPE html>
<html lang="zh-CN" data-default-color-scheme=auto>



<head>
  <meta charset="UTF-8">

  <link rel="apple-touch-icon" sizes="76x76" href="/img/icon.png">
  <link rel="icon" href="/img/icon.png">
  

  <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=5.0, shrink-to-fit=no">
  <meta http-equiv="x-ua-compatible" content="ie=edge">
  
  <meta name="theme-color" content="#2f4154">
  <meta name="author" content="John Doe">
  <meta name="keywords" content="">
  
    <meta name="description" content="LeetCode Hot 100 [11-20] 刷完了《剑指Offer》，下一阶段，开始 LeetCode Hot 100。 之前一直都用思维导图记录，今天发现思维导图可以导出成markdown，简单编辑一下就可以成为文章。相比Xmind，博客文章打开和查看更加方便，所以之后每次Xmind记录之后，会再在这里同时同步一下  前言HOT100，之前的文章传送门LeetCode Hot 100 刷题">
<meta property="og:type" content="article">
<meta property="og:title" content="LeetCode Hot 100 刷题 [21-30]">
<meta property="og:url" content="http://example.com/2022/07/28/LeetCode-Hot-100-%E5%88%B7%E9%A2%98-21-30/index.html">
<meta property="og:site_name" content="Hexo">
<meta property="og:description" content="LeetCode Hot 100 [11-20] 刷完了《剑指Offer》，下一阶段，开始 LeetCode Hot 100。 之前一直都用思维导图记录，今天发现思维导图可以导出成markdown，简单编辑一下就可以成为文章。相比Xmind，博客文章打开和查看更加方便，所以之后每次Xmind记录之后，会再在这里同时同步一下  前言HOT100，之前的文章传送门LeetCode Hot 100 刷题">
<meta property="og:locale" content="zh_CN">
<meta property="article:published_time" content="2022-07-28T01:47:00.000Z">
<meta property="article:modified_time" content="2023-07-15T09:48:48.715Z">
<meta property="article:author" content="John Doe">
<meta property="article:tag" content="LeetCode">
<meta property="article:tag" content="算法">
<meta name="twitter:card" content="summary_large_image">
  
  
  
  <title>LeetCode Hot 100 刷题 [21-30] - Hexo</title>

  <link  rel="stylesheet" href="https://lib.baomitu.com/twitter-bootstrap/4.6.1/css/bootstrap.min.css" />



  <link  rel="stylesheet" href="https://lib.baomitu.com/github-markdown-css/4.0.0/github-markdown.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/hint.css/2.7.0/hint.min.css" />

  <link  rel="stylesheet" href="https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.css" />



<!-- 主题依赖的图标库，不要自行修改 -->
<!-- Do not modify the link that theme dependent icons -->

<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1749284_5i9bdhy70f8.css">



<link rel="stylesheet" href="//at.alicdn.com/t/c/font_1736178_k526ubmyhba.css">


<link  rel="stylesheet" href="/css/main.css" />


  <link id="highlight-css" rel="stylesheet" href="/css/highlight.css" />
  
    <link id="highlight-css-dark" rel="stylesheet" href="/css/highlight-dark.css" />
  




  <script id="fluid-configs">
    var Fluid = window.Fluid || {};
    Fluid.ctx = Object.assign({}, Fluid.ctx)
    var CONFIG = {"hostname":"example.com","root":"/","version":"1.9.8","typing":{"enable":true,"typeSpeed":70,"cursorChar":"_","loop":false,"scope":[]},"anchorjs":{"enable":true,"element":"h1,h2,h3,h4,h5,h6","placement":"left","visible":"hover","icon":""},"progressbar":{"enable":true,"height_px":3,"color":"#29d","options":{"showSpinner":false,"trickleSpeed":100}},"code_language":{"enable":true,"default":"TEXT"},"copy_btn":true,"image_caption":{"enable":true},"image_zoom":{"enable":true,"img_url_replace":["",""]},"toc":{"enable":true,"placement":"right","headingSelector":"h1,h2,h3,h4,h5,h6","collapseDepth":0},"lazyload":{"enable":true,"loading_img":"/img/loading.gif","onlypost":false,"offset_factor":2},"web_analytics":{"enable":true,"follow_dnt":true,"baidu":null,"google":{"measurement_id":null},"tencent":{"sid":null,"cid":null},"leancloud":{"app_id":null,"app_key":null,"server_url":null,"path":"window.location.pathname","ignore_local":false},"umami":{"src":null,"website_id":null,"domains":null,"start_time":"2024-01-01T00:00:00.000Z","token":null,"api_server":null}},"search_path":"/local-search.xml","include_content_in_search":true};

    if (CONFIG.web_analytics.follow_dnt) {
      var dntVal = navigator.doNotTrack || window.doNotTrack || navigator.msDoNotTrack;
      Fluid.ctx.dnt = dntVal && (dntVal.startsWith('1') || dntVal.startsWith('yes') || dntVal.startsWith('on'));
    }
  </script>
  <script  src="/js/utils.js" ></script>
  <script  src="/js/color-schema.js" ></script>
  

  

  

  

  

  



  
<meta name="generator" content="Hexo 7.3.0"></head>


<body>
  

  <header>
    

<div class="header-inner" style="height: 70vh;">
  <nav id="navbar" class="navbar fixed-top  navbar-expand-lg navbar-dark scrolling-navbar">
  <div class="container">
    <a class="navbar-brand" href="/">
      <strong>CodeRat的博客</strong>
    </a>

    <button id="navbar-toggler-btn" class="navbar-toggler" type="button" data-toggle="collapse"
            data-target="#navbarSupportedContent"
            aria-controls="navbarSupportedContent" aria-expanded="false" aria-label="Toggle navigation">
      <div class="animated-icon"><span></span><span></span><span></span></div>
    </button>

    <!-- Collapsible content -->
    <div class="collapse navbar-collapse" id="navbarSupportedContent">
      <ul class="navbar-nav ml-auto text-center">
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/" target="_self">
                <i class="iconfont icon-home-fill"></i>
                <span>首页</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/archives/" target="_self">
                <i class="iconfont icon-archive-fill"></i>
                <span>归档</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/categories/" target="_self">
                <i class="iconfont icon-category-fill"></i>
                <span>分类</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/tags/" target="_self">
                <i class="iconfont icon-tags-fill"></i>
                <span>标签</span>
              </a>
            </li>
          
        
          
          
          
          
            <li class="nav-item">
              <a class="nav-link" href="/about/" target="_self">
                <i class="iconfont icon-user-fill"></i>
                <span>关于</span>
              </a>
            </li>
          
        
        
          <li class="nav-item" id="search-btn">
            <a class="nav-link" target="_self" href="javascript:;" data-toggle="modal" data-target="#modalSearch" aria-label="Search">
              <i class="iconfont icon-search"></i>
            </a>
          </li>
          
        
        
          <li class="nav-item" id="color-toggle-btn">
            <a class="nav-link" target="_self" href="javascript:;" aria-label="Color Toggle">
              <i class="iconfont icon-dark" id="color-toggle-icon"></i>
            </a>
          </li>
        
      </ul>
    </div>
  </div>
</nav>

  

<div id="banner" class="banner" parallax=true
     style="background: url('/img/backdrop.png') no-repeat center center; background-size: cover;">
  <div class="full-bg-img">
    <div class="mask flex-center" style="background-color: rgba(0, 0, 0, 0.3)">
      <div class="banner-text text-center fade-in-up">
        <div class="h2">
          
            <span id="subtitle" data-typed-text="LeetCode Hot 100 刷题 [21-30]"></span>
          
        </div>

        
          
  <div class="mt-3">
    
    
      <span class="post-meta">
        <i class="iconfont icon-date-fill" aria-hidden="true"></i>
        <time datetime="2022-07-28 09:47" pubdate>
          2022年7月28日 上午
        </time>
      </span>
    
  </div>

  <div class="mt-1">
    
      <span class="post-meta mr-2">
        <i class="iconfont icon-chart"></i>
        
          5.3k 字
        
      </span>
    

    
      <span class="post-meta mr-2">
        <i class="iconfont icon-clock-fill"></i>
        
        
        
          45 分钟
        
      </span>
    

    
    
  </div>


        
      </div>

      
    </div>
  </div>
</div>

</div>

  </header>

  <main>
    
      

<div class="container-fluid nopadding-x">
  <div class="row nomargin-x">
    <div class="side-col d-none d-lg-block col-lg-2">
      

    </div>

    <div class="col-lg-8 nopadding-x-md">
      <div class="container nopadding-x-md" id="board-ctn">
        <div id="board">
          <article class="post-content mx-auto">
            <h1 id="seo-header">LeetCode Hot 100 刷题 [21-30]</h1>
            
            
              <div class="markdown-body">
                
                <h1 id="LeetCode-Hot-100-11-20"><a href="#LeetCode-Hot-100-11-20" class="headerlink" title="LeetCode Hot 100 [11-20]"></a>LeetCode Hot 100 [11-20]</h1><blockquote>
<p>刷完了《剑指Offer》，下一阶段，开始 LeetCode Hot 100。 之前一直都用思维导图记录，今天发现思维导图可以导出成markdown，简单编辑一下就可以成为文章。相比Xmind，博客文章打开和查看更加方便，所以之后每次Xmind记录之后，会再在这里同时同步一下</p>
</blockquote>
<h2 id="前言"><a href="#前言" class="headerlink" title="前言"></a>前言</h2><p>HOT100，之前的文章传送门<br><a target="_blank" rel="noopener" href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot100-shua-ti-1-10.html">LeetCode Hot 100 刷题 [1-10]</a><br><a target="_blank" rel="noopener" href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot-100-shua-ti-11-20.html">LeetCode Hot 100 刷题 [11-20]</a></p>
<h2 id="21-接雨水问题"><a href="#21-接雨水问题" class="headerlink" title="21.接雨水问题"></a>21.接雨水问题</h2><h3 id="题目"><a href="#题目" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给定 n 个非负整数表示每个宽度为 1 的柱子的高度图，计算按此排列的柱子，下雨之后能接多少雨水。</li>
</ul>
</blockquote>
<ul>
<li>输入: [0,1,0,2,1,0,1,3,2,1,2,1]</li>
<li>输出: 6</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/trapping-rain-water/">题目地址</a></li>
<li>这是一道Hard题</li>
</ul>
<p>	</p>
<h3 id="解题思路"><a href="#解题思路" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：暴力算法"><a href="#思路1：暴力算法" class="headerlink" title="思路1：暴力算法"></a>思路1：暴力算法</h4><ul>
<li>按列，统计每个列上可以存的雨水的量</li>
<li>如何计算某个列上存水的量<ol>
<li>遍历找出该列左边的最大高度，maxleft</li>
<li>遍历找出该列右边的最大高度，maxRight</li>
<li>水的高度取决于maxLeft和maxRight中的较小者</li>
<li>这个列上水的深度为水的高度 - 该列的高度</li>
</ol>
</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>      <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>      <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span><span class="hljs-number">0</span>; i &lt; height.length; i++)&#123;<br>          <span class="hljs-comment">// find max left</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">leftMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; i; j++)&#123;<br>              leftMax = Math.max(leftMax, height[j]);<br>          &#125;<br>          <span class="hljs-comment">// find max right</span><br>          <span class="hljs-type">int</span> <span class="hljs-variable">rightMax</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>          <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> i+<span class="hljs-number">1</span>; j&lt;height.length; j++)&#123;<br>              rightMax = Math.max(rightMax, height[j]);<br>          &#125;<br>          <span class="hljs-type">int</span> <span class="hljs-variable">validHeight</span> <span class="hljs-operator">=</span> Math.min(leftMax,rightMax);<br>          res += Math.max(<span class="hljs-number">0</span>, validHeight-height[i]);<br>      &#125;<br>      <span class="hljs-keyword">return</span> res;<br>  &#125;<br></code></pre></td></tr></table></figure></li>
<li>算法复杂度<ul>
<li>时间复杂度O(N^2)</li>
</ul>
</li>
</ul>
<h4 id="思路2：动态规划"><a href="#思路2：动态规划" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h4><ul>
<li>对思路1进行优化，思路1中查找左右最大值的过程可以通过DP优化</li>
<li>定义maxLeftDP[ i ] 为 i 左边的最大高度，同理，maxRightDp[ i ]为 i 右边的最大高度 </li>
<li>maxLeftDP[ i ] &#x3D; Max{ maxLeftDP[ i-1 ] , height[ i-1 ] }</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> [] maxLeftDP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [height.length];<br>       <span class="hljs-type">int</span> [] maxRightDP = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [height.length];<br>       <span class="hljs-type">int</span> <span class="hljs-variable">size</span> <span class="hljs-operator">=</span> height.length;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; size-<span class="hljs-number">1</span>; i++)&#123;<br>           maxLeftDP[i] = Math.max(maxLeftDP[i-<span class="hljs-number">1</span>], height[i-<span class="hljs-number">1</span>]);<br>           maxRightDP[size-<span class="hljs-number">1</span>- i] = Math.max(maxRightDP[ size-i], height[size-i]);<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; height.length-<span class="hljs-number">1</span>; i++)&#123;<br>           <span class="hljs-type">int</span> <span class="hljs-variable">validHeight</span> <span class="hljs-operator">=</span> Math.min(maxLeftDP[i],maxRightDP[i]);<br>           res += Math.max(<span class="hljs-number">0</span>, validHeight-height[i]);<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(N)</li>
</ul>
</li>
</ul>
<h4 id="思路3：双指针解法"><a href="#思路3：双指针解法" class="headerlink" title="思路3：双指针解法"></a>思路3：双指针解法</h4><ul>
<li>对思路2中的空间复杂度还可以进一步优化</li>
<li>DP递推方程中，maxLeft和maxRight其实只用到左右边的一个，其实可以不用数组来存储</li>
<li>maxLeftDP是直接可以用变量来替代的，但是maxRightDP的求解是从右向左的，不方便直接用变量来替代</li>
<li>思路与过程<ul>
<li>left、right双指针从两端进行更新</li>
<li>maxLeft、maxRight记录left和right位置对应的左右最大值</li>
<li>maxLeft和maxRight中，起作用的是他们中的较小值，所以每次left和right指针更新较小值的一端</li>
</ul>
</li>
<li>如何选择更新哪一段<ul>
<li>maxLeft &lt; maxRight<ul>
<li>可以保证maxLeft为left左边最大值，且它是起作用的</li>
<li>left指针前进，同时更新maxleft<br>  maxLeft &gt; maxRight</li>
<li>同理，可以保障maxRight为right右边最大值，且它比maxLeft要小，所以即便加上右边还没检查的部分，最终的maxLeft还是比maxRight大，即起作用的还是maxRight</li>
<li>所以，right指针前进，同时更新maxRight</li>
</ul>
</li>
<li>让我想起了类似的用双指针求最大面积的题目<ul>
<li>每次搜索高度较小的一边</li>
</ul>
</li>
</ul>
</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">trap</span><span class="hljs-params">(<span class="hljs-type">int</span>[] height)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">res</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = height.length - <span class="hljs-number">1</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">maxLeft</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, maxRight = <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">while</span>( left &lt;= right)&#123;<br>           <span class="hljs-comment">// maxLeft 起作用</span><br>           <span class="hljs-keyword">if</span>( height[left] &lt; maxRight &amp;&amp; maxLeft &lt; maxRight )&#123;<br>               <span class="hljs-keyword">if</span>( height[left] &gt; maxLeft )&#123;<br>                   maxLeft = height[left];<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                   res += maxLeft - height[left];<br>               &#125; <br>               left++;<br>           &#125; <span class="hljs-keyword">else</span> &#123; <span class="hljs-comment">// maxRight 起作用</span><br>               <span class="hljs-keyword">if</span>( height[right] &gt; maxRight )&#123;<br>                   maxRight = height[right];<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                   res += maxRight - height[right];<br>               &#125; <br>               right--;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> res;<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
</li>
</ul>
<h2 id="22-旋转图像"><a href="#22-旋转图像" class="headerlink" title="22.旋转图像"></a>22.旋转图像</h2><h3 id="题目-1"><a href="#题目-1" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给定一个 n × n 的二维矩阵表示一个图像。</li>
</ul>
</blockquote>
<ul>
<li>将图像顺时针旋转 90 度。</li>
<li>你必须在原地旋转图像，这意味着你需要直接修改输入的二维矩阵。请不要使用另一个矩阵来旋转图像。</li>
<li>给定 matrix &#x3D; <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">[<br>  [<span class="hljs-number">1</span>,<span class="hljs-number">2</span>,<span class="hljs-number">3</span>],<br>  [<span class="hljs-number">4</span>,<span class="hljs-number">5</span>,<span class="hljs-number">6</span>],<br>  [<span class="hljs-number">7</span>,<span class="hljs-number">8</span>,<span class="hljs-number">9</span>]<br>]<br></code></pre></td></tr></table></figure></li>
<li>原地旋转输入矩阵，使其变为:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">[<br>  [<span class="hljs-number">7</span>,<span class="hljs-number">4</span>,<span class="hljs-number">1</span>],<br>  [<span class="hljs-number">8</span>,<span class="hljs-number">5</span>,<span class="hljs-number">2</span>],<br>  [<span class="hljs-number">9</span>,<span class="hljs-number">6</span>,<span class="hljs-number">3</span>]<br>]<br></code></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/rotate-image">题目地址</a></li>
</ul>
<h3 id="解题思路-1"><a href="#解题思路-1" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：转置-行交换"><a href="#思路1：转置-行交换" class="headerlink" title="思路1：转置+行交换"></a>思路1：转置+行交换</h4><ul>
<li>思路与过程<ol>
<li>将行按照对称的方式进行交换<ul>
<li>a[i][j] 与 a[ len-i-1 ][j]交换</li>
</ul>
</li>
<li>将处理后的矩阵按对角进行转置<ul>
<li>a[i][j] 与 a[j][i]交换</li>
</ul>
</li>
</ol>
</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rotate</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] matrix)</span> &#123;<br>       <span class="hljs-comment">// 水平交换</span><br>       <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = matrix.length-<span class="hljs-number">1</span>;<br><br>       <span class="hljs-keyword">while</span>( left &lt; right)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; matrix[<span class="hljs-number">0</span>].length;i++)&#123;<br>               rowSwap(matrix, left, right, i);<br>           &#125;<br>           left++;<br>           right--;<br>       &#125;<br>       <span class="hljs-comment">// 对角线对称</span><br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt;matrix.length; i++)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j&lt; i; j++)&#123;<br>               angleSwap(matrix,i,j);<br>           &#125;<br>       &#125;<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">rowSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> [][] matrix, <span class="hljs-type">int</span> left, <span class="hljs-type">int</span> right , <span class="hljs-type">int</span> i)</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[left][i];<br>       matrix[left][i] = matrix[right][i];<br>       matrix[right][i] = temp;<br>   &#125;<br><br>   <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">angleSwap</span><span class="hljs-params">(<span class="hljs-type">int</span> [][] matrix, <span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j)</span>&#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">temp</span> <span class="hljs-operator">=</span> matrix[i][j];<br>       matrix[i][j] = matrix[j][i];<br>       matrix[j][i] = temp;<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度评估<ul>
<li>时间复杂度O(N^2)</li>
</ul>
</li>
</ul>
<h2 id="23-字母异位词分组"><a href="#23-字母异位词分组" class="headerlink" title="23.字母异位词分组"></a>23.字母异位词分组</h2><h3 id="题目-2"><a href="#题目-2" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给定一个字符串数组，将字母异位词组合在一起。字母异位词指字母相同，但排列不同的字符串。</li>
</ul>
</blockquote>
<ul>
<li>输入: [“eat”, “tea”, “tan”, “ate”, “nat”, “bat”]</li>
<li>输出:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br></pre></td><td class="code"><pre><code class="hljs java">[<br>  [<span class="hljs-string">&quot;ate&quot;</span>,<span class="hljs-string">&quot;eat&quot;</span>,<span class="hljs-string">&quot;tea&quot;</span>],<br>  [<span class="hljs-string">&quot;nat&quot;</span>,<span class="hljs-string">&quot;tan&quot;</span>],<br>  [<span class="hljs-string">&quot;bat&quot;</span>]<br>]<br>```		<br>- 所有输入均为小写字母。<br>- 不考虑答案输出的顺序。<br>- [题目地址](https:<span class="hljs-comment">//leetcode-cn.com/problems/group-anagrams/)</span><br><br>### 解题思路<br>#### 思路<span class="hljs-number">1</span>：排序 + HashMap<br>- 对每一个字符串的字符按字典序进行排序<br>- 将排序后的结果作为HashMap的key，value为列表<br>- 最终将HashMap的values输出为列表<br>    - values()，返回的是数组，不是List，需要将数组转化成list<br>	- Java8 Stream API:`hashMap.values().stream().collect(Collectors.toList())`<br>	- Java8之前：`<span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>(hashMap.values())`<br>- 代码实现<br>```java<br>	<span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>        HashMap&lt;String, List&lt;String&gt;&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>        <span class="hljs-keyword">for</span>(String str : strs)&#123;<br>            <span class="hljs-type">char</span> [] values = str.toCharArray();<br>            Arrays.sort(values);<br>            <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">String</span>(values);<br>            <span class="hljs-keyword">if</span>(hashMap.containsKey(key))&#123;<br>                hashMap.get(key).add(str);<br>            &#125;<span class="hljs-keyword">else</span>&#123;<br>                List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>                list.add(str);<br>                hashMap.put(key,list);<br>            &#125;<br>        &#125;<br>        <span class="hljs-keyword">return</span> hashMap.values().stream().collect(Collectors.toList());<br>    &#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(Nklogk)</li>
<li>空间复杂度O(NK)</li>
</ul>
</li>
</ul>
<h4 id="思路2：字符计数-HashMap"><a href="#思路2：字符计数-HashMap" class="headerlink" title="思路2：字符计数 + HashMap"></a>思路2：字符计数 + HashMap</h4><ul>
<li>与思路1基本类似，只是key的生成方式不一样</li>
<li>思路1需要排序，O(klogk)，还是比较高的</li>
<li>可以统计每个字符串中26个字母出现的次数，作为模式，模式作为hashmap的key<ul>
<li>计数模式：<code>int [ ] count = new int [26]</code></li>
<li>最后的模式串：<code>1#0#6#...</code></li>
</ul>
</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> List&lt;List&lt;String&gt;&gt; <span class="hljs-title function_">groupAnagrams</span><span class="hljs-params">(String[] strs)</span> &#123;<br>       HashMap&lt;String, List&lt;String&gt;&gt; hashMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>();<br>       <span class="hljs-type">int</span> [] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [<span class="hljs-number">26</span>];<br>       <span class="hljs-keyword">for</span>(String str : strs)&#123;<br>           <span class="hljs-type">char</span> [] values = str.toCharArray();<br>           Arrays.fill(count, <span class="hljs-number">0</span>);<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">char</span> ch : values)&#123;<br>               count[ch-<span class="hljs-string">&#x27;a&#x27;</span>]++;<br>           &#125;<br>           <span class="hljs-type">StringBuilder</span> <span class="hljs-variable">builder</span> <span class="hljs-operator">=</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">StringBuilder</span>();<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> num:count)&#123;<br>               builder.append(num);<br>               builder.append(<span class="hljs-string">&#x27;,&#x27;</span>);<br>           &#125;<br>           <span class="hljs-type">String</span> <span class="hljs-variable">key</span> <span class="hljs-operator">=</span> builder.toString();<br>           <span class="hljs-keyword">if</span>(hashMap.containsKey(key))&#123;<br>               hashMap.get(key).add(str);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               List&lt;String&gt; list = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>               list.add(str);<br>               hashMap.put(key,list);<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> hashMap.values().stream().collect(Collectors.toList());<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(NK)</li>
<li>空间复杂度O(NK)</li>
</ul>
</li>
</ul>
<h2 id="24-跳跃游戏"><a href="#24-跳跃游戏" class="headerlink" title="24.跳跃游戏"></a>24.跳跃游戏</h2><h3 id="题目-3"><a href="#题目-3" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给定一个非负整数数组，你最初位于数组的第一个位置。</li>
</ul>
</blockquote>
<ul>
<li>数组中的每个元素代表你在该位置可以跳跃的最大长度。</li>
<li>判断你是否能够到达最后一个位置。</li>
<li>输入: [2,3,1,1,4]</li>
<li>输出: true</li>
<li>解释: 我们可以先跳 1 步，从位置 0 到达 位置 1, 然后再从位置 1 跳 3 步到达最后一个位置。</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/jump-game/">题目地址</a></li>
</ul>
<h3 id="解题思路-2"><a href="#解题思路-2" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：排除法"><a href="#思路1：排除法" class="headerlink" title="思路1：排除法"></a>思路1：排除法</h4><ul>
<li>研究什么时候跳不到终点<ol>
<li>序列中有 0 的时候，才会可能跳不到终点</li>
<li>当 0 前边所有的数都无法跳过 0 ，则必定跳不过去<ul>
<li>即该位置的值，小于等于该位置距离0的格数</li>
</ul>
</li>
<li>最后一个为0不影响</li>
</ol>
</li>
<li>思路过程</li>
</ul>
<ol>
<li>遍历数组，检索所有的0<ul>
<li>最后一个位置是否为0不影响，所以不用判断</li>
</ul>
</li>
<li>对每一个0， 向前遍历，是否存在能跳跃过它的数</li>
<li>所有的都满足，则可以到达最后一个位置</li>
</ol>
<ul>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; nums.length-<span class="hljs-number">1</span>; i++)&#123;<br>        <span class="hljs-comment">// 最后一个是0还是非0对结果不影响</span><br>           <span class="hljs-keyword">if</span>(nums[i] == <span class="hljs-number">0</span>)&#123;<br>               <span class="hljs-type">int</span> j,dis=<span class="hljs-number">1</span>;<br>               <span class="hljs-keyword">for</span>(j = i-<span class="hljs-number">1</span>; j &gt;= <span class="hljs-number">0</span>; j--,dis++)&#123;<br>                   <span class="hljs-keyword">if</span>(nums[j] &gt; dis) <span class="hljs-keyword">break</span>;<br>               &#125;<br>               <span class="hljs-keyword">if</span>(j &lt; <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(N^2)</li>
<li>空间复杂度O(1)</li>
</ul>
</li>
</ul>
<h4 id="思路2：贪心算法"><a href="#思路2：贪心算法" class="headerlink" title="思路2：贪心算法"></a>思路2：贪心算法</h4><ul>
<li>是本题的最优解法，也应该是主要的考察点</li>
<li>比较不容易想到贪心规则</li>
<li>某一位置可达，则该位置之前的位置均是可达的</li>
<li>所以，只要保障能到达的位置超过数组最后一个位置就可以了<ul>
<li>因此，每次都尽可能的向远处跳</li>
</ul>
</li>
<li>思路过程</li>
</ul>
<ol>
<li>mostFarIndex 标识目前能到达的最远位置</li>
<li>当前位置在最远位置或之前，则说明最远位置可能还可以更大，更新最远位置</li>
<li>若当前位置在最远位置之后了，则最远位置再也没法更新了，也就最终无法超越最后一个位置了</li>
</ol>
<ul>
<li><p>代码实现</p>
<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">boolean</span> <span class="hljs-title function_">canJump</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;        <br>       <span class="hljs-type">int</span> <span class="hljs-variable">mostFarIndex</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> i=<span class="hljs-number">0</span>; i &lt; nums.length-<span class="hljs-number">1</span>; i++)&#123; <span class="hljs-comment">// 最后一个不影响</span><br>           <span class="hljs-keyword">if</span>( i &lt;= mostFarIndex )&#123;<br>               mostFarIndex = Math.max(mostFarIndex, i + nums[i]);<br>               <span class="hljs-keyword">if</span>(mostFarIndex &gt;= nums.length-<span class="hljs-number">1</span>) <span class="hljs-keyword">return</span> <span class="hljs-literal">true</span>;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               <span class="hljs-keyword">return</span> <span class="hljs-literal">false</span>;<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> mostFarIndex &gt;= nums.length-<span class="hljs-number">1</span>;<br>   &#125;<br></code></pre></td></tr></table></figure>
</li>
<li><p>复杂度分析</p>
<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
</li>
</ul>
<h2 id="25-合并区间"><a href="#25-合并区间" class="headerlink" title="25.合并区间"></a>25.合并区间</h2><h3 id="题目-4"><a href="#题目-4" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>出一个区间的集合，请合并所有重叠的区间。</li>
</ul>
</blockquote>
<ul>
<li>示例</li>
<li>输入: [[1,3],[2,6],[8,10],[15,18]]</li>
<li>输出: [[1,6],[8,10],[15,18]]</li>
<li>解释: 区间 [1,3] 和 [2,6] 重叠, 将它们合并为 [1,6].</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/merge-intervals">题目链接</a></li>
</ul>
<h3 id="解题思路-3"><a href="#解题思路-3" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>先将区间按照左边界的大小排序<ul>
<li>lambda实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">Arrays.sort(intervals, (<span class="hljs-type">int</span> [] a, <span class="hljs-type">int</span> [] b)-&gt;&#123;<br>        <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>&#125;);<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>然后遍历区间数组，相邻的区间能合并则合并</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span>[][] merge(<span class="hljs-type">int</span>[][] intervals) &#123;<br>       <span class="hljs-keyword">if</span>(intervals.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>       ArrayList&lt;<span class="hljs-type">int</span> []&gt; res = <span class="hljs-keyword">new</span> <span class="hljs-title class_">ArrayList</span>();<br>       <span class="hljs-comment">// 按第一个排序</span><br>       Arrays.sort(intervals, (<span class="hljs-type">int</span> [] a, <span class="hljs-type">int</span> [] b)-&gt;&#123;<br>           <span class="hljs-keyword">return</span> a[<span class="hljs-number">0</span>] - b[<span class="hljs-number">0</span>];<br>       &#125;);<br>       <span class="hljs-type">int</span> <span class="hljs-variable">start</span> <span class="hljs-operator">=</span> intervals[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>], end = intervals[<span class="hljs-number">0</span>][<span class="hljs-number">1</span>];<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt;intervals.length; i++)&#123;<br>           <span class="hljs-keyword">if</span>(intervals[i][<span class="hljs-number">0</span>] &lt;= end)&#123;<br>               end = Math.max(end, intervals[i][<span class="hljs-number">1</span>]);<br>           &#125;<span class="hljs-keyword">else</span>&#123;<br>               res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start, end&#125;);<br>               start = intervals[i][<span class="hljs-number">0</span>];<br>               end = intervals[i][<span class="hljs-number">1</span>];<br>           &#125;<br>       &#125;<br>       res.add(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[]&#123;start, end&#125;);<br>       <span class="hljs-keyword">return</span> res.toArray(<span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[res.size()][<span class="hljs-number">2</span>]);<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>O(NlogN)</li>
</ul>
</li>
</ul>
<h2 id="26-不同路径"><a href="#26-不同路径" class="headerlink" title="26.不同路径"></a>26.不同路径</h2><h3 id="题目-5"><a href="#题目-5" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>一个机器人位于一个 m x n 网格的左上角 （起始点在下图中标记为“Start” ）。</li>
</ul>
</blockquote>
<ul>
<li>机器人每次只能向下或者向右移动一步。机器人试图达到网格的右下角（在下图中标记为“Finish”）。</li>
<li>问总共有多少条不同的路径？</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/unique-paths">题目链接</a></li>
</ul>
<h3 id="解题思路-4"><a href="#解题思路-4" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>典型的深度优先遍历，动态规划解题</li>
</ul>
<h4 id="思路1：DFS-回溯"><a href="#思路1：DFS-回溯" class="headerlink" title="思路1：DFS+回溯"></a>思路1：DFS+回溯</h4><ul>
<li>从左上角出发，分别尝试向下和向右，然后回溯</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">class</span> <span class="hljs-title class_">Solution</span> &#123;<br>    <span class="hljs-keyword">private</span> <span class="hljs-type">int</span> <span class="hljs-variable">count</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>    <span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>        dfs(<span class="hljs-number">0</span>,<span class="hljs-number">0</span>,m,n);<br>        <span class="hljs-keyword">return</span> count;<br>    &#125;<br><br>    <span class="hljs-keyword">private</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">dfs</span><span class="hljs-params">(<span class="hljs-type">int</span> i, <span class="hljs-type">int</span> j, <span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span>&#123;<br>        <span class="hljs-keyword">if</span>(i &gt;= m || j &gt;= n) <span class="hljs-keyword">return</span>;<br>        <span class="hljs-keyword">if</span>( i == m-<span class="hljs-number">1</span> &amp;&amp; j == n-<span class="hljs-number">1</span>)&#123;<br>            count++;<br>            <span class="hljs-keyword">return</span> ;<br>        &#125;<br>        <span class="hljs-comment">// 向右尝试</span><br>        <span class="hljs-keyword">if</span>(j &lt; n-<span class="hljs-number">1</span>)&#123;<br>            dfs(i,j+<span class="hljs-number">1</span>,m,n);<br>        &#125;<br>        <span class="hljs-comment">// 向左尝试</span><br>        <span class="hljs-keyword">if</span>(i &lt; m -<span class="hljs-number">1</span>)&#123;<br>            dfs(i+<span class="hljs-number">1</span>, j, m,n);<br>        &#125;<br>    &#125;<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O((M+N)^2)</li>
<li>空间复杂度O(（M+N）^2)</li>
</ul>
</li>
</ul>
<h4 id="思路2：动态规划-1"><a href="#思路2：动态规划-1" class="headerlink" title="思路2：动态规划"></a>思路2：动态规划</h4><ul>
<li>dp[ i ][ j ]：到达坐标(i,j)位置有多少个路径<ul>
<li>&#x3D; dp[ i-1 ]dp[ j ] + dp[ i ][ j-1 ]</li>
</ul>
</li>
<li>思路过程<ol>
<li>创建二维dp数组，并进行初始化</li>
<li>dp数组的第一行和第一类初始化为1，因为可以确定只有1个路径</li>
<li>对dp数组进行填表操作</li>
</ol>
</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> [][] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [m][n];<br>    Arrays.fill(dp[<span class="hljs-number">0</span>], <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; m; i++)&#123;<br>        dp[i][<span class="hljs-number">0</span>] = <span class="hljs-number">1</span>;<br>    &#125;<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            dp[i][j] = dp[i-<span class="hljs-number">1</span>][j] + dp[i][j-<span class="hljs-number">1</span>];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[m-<span class="hljs-number">1</span>][n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(M*N)</li>
<li>空间复杂度O(M*N)</li>
</ul>
</li>
</ul>
<h4 id="思路3：动态规划空间优化"><a href="#思路3：动态规划空间优化" class="headerlink" title="思路3：动态规划空间优化"></a>思路3：动态规划空间优化</h4><ul>
<li>思路2中的dp二维数组，可以继续优化成一维数组</li>
<li>因为递归关系中，只使用到了坐标左边和左边上边的位置</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">uniquePaths</span><span class="hljs-params">(<span class="hljs-type">int</span> m, <span class="hljs-type">int</span> n)</span> &#123;<br>    <span class="hljs-type">int</span> [] dp = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [n];<br>    Arrays.fill(dp, <span class="hljs-number">1</span>);<br>    <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt; m; i++)&#123;<br>        <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt; n; j++)&#123;<br>            dp[j] = dp[j-<span class="hljs-number">1</span>] + dp[j];<br>        &#125;<br>    &#125;<br>    <span class="hljs-keyword">return</span> dp[n-<span class="hljs-number">1</span>];<br>&#125;<br></code></pre></td></tr></table></figure></li>
</ul>
<h2 id="27-最小路径和"><a href="#27-最小路径和" class="headerlink" title="27. 最小路径和"></a>27. 最小路径和</h2><h3 id="题目-6"><a href="#题目-6" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给定一个包含非负整数的 m x n 网格，请找出一条从左上角到右下角的路径，使得路径上的数字总和为最小。</li>
</ul>
</blockquote>
<ul>
<li>说明：每次只能向下或者向右移动一步。</li>
<li>输入:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><code class="hljs java">[<br>  [<span class="hljs-number">1</span>,<span class="hljs-number">3</span>,<span class="hljs-number">1</span>],<br>  [<span class="hljs-number">1</span>,<span class="hljs-number">5</span>,<span class="hljs-number">1</span>],<br>  [<span class="hljs-number">4</span>,<span class="hljs-number">2</span>,<span class="hljs-number">1</span>]<br>]<br></code></pre></td></tr></table></figure></li>
<li>输出: 7</li>
<li>解释: 因为路径 1→3→1→1→1 的总和最小。</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-path-sum">link</a></li>
</ul>
<h3 id="解题思路-5"><a href="#解题思路-5" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>思路明显，二维数组动态规划</li>
<li>dp[ i ][ j ]：从起点到达 (i , j)位置的路径和<ul>
<li>dp[ i ][ j ] &#x3D; Math.min(dp[ i ][j-1], dp[ i-1 ][ j ]) + grid[i][j];</li>
<li>只用到了左边和上边的位置，所以可以优化到一维数组</li>
<li>初始状态，i&#x3D;0 以及 j &#x3D; 0，第0行和第0列的初始化</li>
</ul>
</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minPathSum</span><span class="hljs-params">(<span class="hljs-type">int</span>[][] grid)</span> &#123;<br>       <span class="hljs-keyword">if</span>(grid.length == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> dp[] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [grid[<span class="hljs-number">0</span>].length];<br>       dp[<span class="hljs-number">0</span>] = grid[<span class="hljs-number">0</span>][<span class="hljs-number">0</span>];<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span> ; i &lt; dp.length; i++)&#123;<br>           dp[i] = dp[i-<span class="hljs-number">1</span>] + grid[<span class="hljs-number">0</span>][i];<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i&lt;grid.length; i++)&#123;<br>           dp[<span class="hljs-number">0</span>] += grid[i][<span class="hljs-number">0</span>]; <br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j&lt;dp.length; j++)&#123;<br>               dp[j] = Math.min(dp[j-<span class="hljs-number">1</span>], dp[j]) + grid[i][j];<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dp[dp.length-<span class="hljs-number">1</span>];<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(N*M)</li>
<li>空间复杂度O(M)</li>
</ul>
</li>
</ul>
<h2 id="28-编辑距离"><a href="#28-编辑距离" class="headerlink" title="28. 编辑距离"></a>28. 编辑距离</h2><h3 id="题目-7"><a href="#题目-7" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给你两个单词 word1 和 word2，请你计算出将 word1 转换成 word2 所使用的最少操作数 。</li>
</ul>
</blockquote>
<ul>
<li>你可以对一个单词进行如下三种操作：<ul>
<li>插入一个字符</li>
<li>删除一个字符</li>
<li>替换一个字符</li>
</ul>
</li>
<li>输入：word1 &#x3D; “horse”, word2 &#x3D; “ros”</li>
<li>输出：3</li>
<li>解释:<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><code class="hljs java">horse -&gt; rorse (将 <span class="hljs-string">&#x27;h&#x27;</span> 替换为 <span class="hljs-string">&#x27;r&#x27;</span>)<br>rorse -&gt; rose (删除 <span class="hljs-string">&#x27;r&#x27;</span>)<br>rose -&gt; ros (删除 <span class="hljs-string">&#x27;e&#x27;</span>)<br></code></pre></td></tr></table></figure></li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/edit-distance">link</a></li>
</ul>
<h3 id="解题思路-6"><a href="#解题思路-6" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>动态规划解题</li>
</ul>
<ol>
<li>求最优解问题</li>
<li>是可以分阶段进行的<ul>
<li>每个阶段有插入、删除、替换三个选择</li>
<li>插入、删除、替换设定都在末尾进行<ul>
<li>等价的，在中间插入也是可以转换到尾部操作的</li>
</ul>
</li>
</ul>
</li>
<li>最优子结构<ul>
<li>dp[ i ][ j ]，表示将word1的前 i 位 转换成 word2的前 j 位需要的最少操作数</li>
<li>它可以通过三种方式获得，且取三种方式中的最小值</li>
</ul>
<ol>
<li>word1末尾插入<ul>
<li>dp[ i ][ j ] &#x3D; dp[ i-1 ][ j ] + 1;</li>
<li>hors -&gt; ros 需要a步，则horse -&gt; ros 需要 a+1 步</li>
</ul>
</li>
<li>word1末尾删除<ul>
<li>dp[ i ][ j ] &#x3D; dp[ i ][ j-1 ] + 1;</li>
<li>hors -&gt; ro需要 b 步，则 hors -&gt; ros 需要 b+1 步</li>
</ul>
</li>
<li>word1末尾替换<ul>
<li>dp[ i ][ j ] &#x3D; dp[ i-1 ][ j-1 ] + 1 ，如果 i 和 j 字符不同， 则需要额外一次替换操作<ul>
<li>hors - &gt; ro 为 c， 则horo -&gt; ro需要额外一次替换操作</li>
</ul>
</li>
<li>dp[ i ][ j ] &#x3D; dp[ i-1 ][ j ] , 如果 i 和 j 字符相同，则不需要额外一次操作 <ul>
<li>hor -&gt; ro 为 d ，则 hors -&gt; ros 为 d</li>
</ul>
</li>
</ul>
</li>
</ol>
</li>
</ol>
<ul>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-type">int</span> <span class="hljs-title function_">minDistance</span><span class="hljs-params">(String word1, String word2)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">len1</span> <span class="hljs-operator">=</span> word1.length(), len2 = word2.length();<br>       <span class="hljs-keyword">if</span>(len1 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> len2;<br>       <span class="hljs-keyword">if</span>(len2 == <span class="hljs-number">0</span>) <span class="hljs-keyword">return</span> len1;<br>       <span class="hljs-type">int</span> dp[][] = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span> [len1 +<span class="hljs-number">1</span> ][len2+<span class="hljs-number">1</span>];<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt;= len1; i++ )&#123;<br>           dp[i][<span class="hljs-number">0</span>] = i;<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i&lt;= len2; i++)&#123;<br>           dp[<span class="hljs-number">0</span>][i] = i;<br>       &#125;<br>       <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; i &lt;= len1; i++)&#123;<br>           <span class="hljs-keyword">for</span>(<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">1</span>; j &lt;= len2; j++)&#123;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">insert</span> <span class="hljs-operator">=</span> dp[i-<span class="hljs-number">1</span>][j] + <span class="hljs-number">1</span>;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">remove</span> <span class="hljs-operator">=</span> dp[i][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>               <span class="hljs-type">int</span> <span class="hljs-variable">replace</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>               <span class="hljs-keyword">if</span>(word1.charAt(i-<span class="hljs-number">1</span>) == word2.charAt(j-<span class="hljs-number">1</span>))&#123;<br>                   replace = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>];<br>               &#125;<span class="hljs-keyword">else</span>&#123;<br>                   replace = dp[i-<span class="hljs-number">1</span>][j-<span class="hljs-number">1</span>] + <span class="hljs-number">1</span>;<br>               &#125;<br>               dp[i][j] = Stream.of(insert,remove, replace)<br>               .min(Comparator.comparing(Integer::valueOf)).get();<br>           &#125;<br>       &#125;<br>       <span class="hljs-keyword">return</span> dp[len1][len2];<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(M*N)</li>
<li>空间复杂度O(M*N)</li>
</ul>
</li>
</ul>
<h2 id="29-颜色排序"><a href="#29-颜色排序" class="headerlink" title="29. 颜色排序"></a>29. 颜色排序</h2><h3 id="题目-8"><a href="#题目-8" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给定一个包含红色、白色和蓝色，一共 n 个元素的数组，原地对它们进行排序，使得相同颜色的元素相邻，并按照红色、白色、蓝色顺序排列。</li>
</ul>
</blockquote>
<ul>
<li>此题中，我们使用整数 0、 1 和 2 分别表示红色、白色和蓝色。</li>
<li>不能使用代码库中的排序函数来解决这道题。</li>
<li>输入: [2,0,2,1,1,0]</li>
<li>输出: [0,0,1,1,2,2]</li>
<li>进阶<ul>
<li>一个直观的解决方案是使用计数排序的两趟扫描算法。</li>
<li>首先，迭代计算出0、1 和 2 元素的个数，然后按照0、1、2的排序，重写当前数组。</li>
<li>你能想出一个仅使用常数空间的一趟扫描算法吗？</li>
</ul>
</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/sort-colors">题目地址</a></li>
</ul>
<p>	</p>
<h3 id="解题思路-7"><a href="#解题思路-7" class="headerlink" title="解题思路"></a>解题思路</h3><h4 id="思路1：计数排序算法"><a href="#思路1：计数排序算法" class="headerlink" title="思路1：计数排序算法"></a>思路1：计数排序算法</h4><ul>
<li>计数排序<ol>
<li>数组统计各种元素的出现频数</li>
<li>对频数数组进行连续累加，对应的数字便是该类值插入位置的后一个</li>
<li>读取原数组中的数字，并查找频数数组，确定插入的位置<ul>
<li>插入成功之后，频数数组对应的值-1</li>
<li>即，插入位置前移一个</li>
</ul>
</li>
</ol>
</li>
<li>这里由于只要对值排序就可以，相同的值之间没有差异，所以得到频数数组之后，直接更改原数组即可</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-type">int</span>[] count = <span class="hljs-keyword">new</span> <span class="hljs-title class_">int</span>[<span class="hljs-number">3</span>];<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; nums.length; i++) &#123;<br>           count[nums[i]]++;<br>       &#125;<br><br>       <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">i</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; i &lt; count.length; i++) &#123;<br>           <span class="hljs-keyword">for</span> (<span class="hljs-type">int</span> <span class="hljs-variable">j</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>; j &lt; count[i]; j++) &#123;<br>               nums[index] = i;<br>               index++;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(K+N)</li>
<li>空间复杂度O(K)</li>
</ul>
</li>
</ul>
<h4 id="思路2：双指针算法"><a href="#思路2：双指针算法" class="headerlink" title="思路2：双指针算法"></a>思路2：双指针算法</h4><ul>
<li>类似三路排序的效果，能够高效处理含有大量重复元素的情况</li>
<li>一路指针标记0的插入位置，另一路标记2的插入位置，0和2排序好了，中间剩下的1便也排序好了</li>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> <span class="hljs-keyword">void</span> <span class="hljs-title function_">sortColors</span><span class="hljs-params">(<span class="hljs-type">int</span>[] nums)</span> &#123;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = nums.length - <span class="hljs-number">1</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">index</span> <span class="hljs-operator">=</span> left;<br>       <span class="hljs-keyword">while</span> (index &lt;= right) &#123;<br>           <span class="hljs-keyword">if</span> (nums[index] == <span class="hljs-number">0</span>) &#123;<br>               swap(nums, index, left);<br>               left++;<br>               index++;<br>           &#125; <span class="hljs-keyword">else</span> <span class="hljs-keyword">if</span> (nums[index] == <span class="hljs-number">2</span>) &#123;<br>               swap(nums, index, right);<br>               right--;<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               index++;<br>           &#125;<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(N)</li>
<li>空间复杂度O(1)</li>
</ul>
</li>
</ul>
<h2 id="30-最小包含子串"><a href="#30-最小包含子串" class="headerlink" title="30.最小包含子串"></a>30.最小包含子串</h2><h3 id="题目-9"><a href="#题目-9" class="headerlink" title="题目"></a>题目</h3><blockquote>
<ul>
<li>给你一个字符串 S、一个字符串 T，请在字符串 S 里面找出：包含 T 所有字符的最小子串。</li>
</ul>
</blockquote>
<ul>
<li>输入: S &#x3D; “ADOBECODEBANC”, T &#x3D; “ABC”</li>
<li>输出: “BANC”</li>
<li>如果 S 中不存这样的子串，则返回空字符串 “”。</li>
<li>如果 S 中存在这样的子串，我们保证它是唯一的答案。</li>
<li><a target="_blank" rel="noopener" href="https://leetcode-cn.com/problems/minimum-window-substring">link</a></li>
</ul>
<h3 id="解题思路-8"><a href="#解题思路-8" class="headerlink" title="解题思路"></a>解题思路</h3><ul>
<li>滑动窗口解题的典型例题</li>
<li>T字符中可能存在重复字符<ul>
<li>对字符进行计数</li>
<li>可以使用数组统计128所有字符</li>
<li>也可以通过HashMap，只统计出现的字符  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : tValues) &#123;<br>       <span class="hljs-keyword">if</span> (tMap.containsKey(c)) &#123;<br>           tMap.put(c, tMap.get(c) + <span class="hljs-number">1</span>);<br>       &#125; <span class="hljs-keyword">else</span> &#123;<br>           tMap.put(c, <span class="hljs-number">1</span>);<br>       &#125;<br>   &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>检测当前窗口是否包含T所有字符<ul>
<li>distance，即窗口内容与T之间的距离</li>
<li>当字符出现在T中，且该字符能缩小窗口与T距离的时候，distance++  <figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-comment">// 字符在t中，更改distance</span><br>      <span class="hljs-keyword">if</span> (winMap.containsKey(sValues[right])) &#123;<br>          <span class="hljs-keyword">if</span> (winMap.get(sValues[right]) &lt; tMap.get(sValues[right])) &#123;<br>              distance++;<br>          &#125;<br>          winMap.put(sValues[right], winMap.get(sValues[right]) + <span class="hljs-number">1</span>);<br>      &#125; <span class="hljs-keyword">else</span> &#123;<br>          winMap.put(sValues[right], <span class="hljs-number">1</span>);<br>          distance++;<br>      &#125;<br></code></pre></td></tr></table></figure></li>
</ul>
</li>
<li>思路与过程</li>
</ul>
<ol>
<li>通过HashMap，统计T字符串中字符的出现次数</li>
<li>left，right&#x3D;0，窗口从左出发</li>
<li>先right右移，right位置元素未在TMap中，则继续右移</li>
<li>当right位置元素出现在TMap中<ul>
<li>如果SMap中该字符数目 &lt; TMap中该字符数目<ul>
<li>distance++</li>
<li>说明该字符能有效降低窗口和T之间的距离</li>
<li>若大于等于，说明该元素重复了</li>
</ul>
</li>
<li>然后SMap中该字符数目+1</li>
</ul>
</li>
<li>检测distance<ul>
<li>如果比T的长度小，则right继续右移</li>
<li>如果和T长度相等，说明当前窗口是满足包含所有T字符的子串，但需要缩小到最小子串</li>
</ul>
</li>
<li>left指针右移<ul>
<li>移动到distance不等于T长度为止</li>
<li>判断left位置字符是否出现在TMap中<ul>
<li>出现，若SMap中该字符频数 &lt;&#x3D; TMap中该字符频数，distance–</li>
</ul>
</li>
<li>SMap中该字符频数-1</li>
</ul>
</li>
<li>最终left的位置便是子串最左位置的下一个<ul>
<li>length &#x3D; right -left +2</li>
<li>更新最短长度以及其实位置</li>
</ul>
</li>
</ol>
<ul>
<li>代码实现<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br></pre></td><td class="code"><pre><code class="hljs java"><span class="hljs-keyword">public</span> String <span class="hljs-title function_">minWindow</span><span class="hljs-params">(String s, String t)</span> &#123;<br>       <span class="hljs-type">char</span>[] sValues = s.toCharArray();<br>       <span class="hljs-type">char</span>[] tValues = t.toCharArray();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">left</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, right = <span class="hljs-number">0</span>;<br>       HashMap&lt;Character, Integer&gt; tMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       HashMap&lt;Character, Integer&gt; winMap = <span class="hljs-keyword">new</span> <span class="hljs-title class_">HashMap</span>&lt;&gt;();<br>       <span class="hljs-type">int</span> <span class="hljs-variable">distance</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>;<br>       <span class="hljs-type">int</span> <span class="hljs-variable">minBegin</span> <span class="hljs-operator">=</span> <span class="hljs-number">0</span>, minLength = Integer.MAX_VALUE;<br><br>       <span class="hljs-keyword">for</span> (<span class="hljs-type">char</span> c : tValues) &#123;<br>           <span class="hljs-keyword">if</span> (tMap.containsKey(c)) &#123;<br>               tMap.put(c, tMap.get(c) + <span class="hljs-number">1</span>);<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               tMap.put(c, <span class="hljs-number">1</span>);<br>           &#125;<br>       &#125;<br><br>       <span class="hljs-keyword">while</span> (right &lt; sValues.length) &#123;<br>           <span class="hljs-comment">// right 右移</span><br>           <span class="hljs-keyword">if</span> (!tMap.containsKey(sValues[right])) &#123;<br>               <span class="hljs-comment">// 字符不在t中，right右移</span><br>               right++;<br>               <span class="hljs-keyword">continue</span>;<br>           &#125;<br>           <span class="hljs-comment">// 字符在t中，更改distance</span><br>           <span class="hljs-keyword">if</span> (winMap.containsKey(sValues[right])) &#123;<br>               <span class="hljs-keyword">if</span> (winMap.get(sValues[right]) &lt; tMap.get(sValues[right])) &#123;<br>                   distance++;<br>               &#125;<br>               winMap.put(sValues[right], winMap.get(sValues[right]) + <span class="hljs-number">1</span>);<br>           &#125; <span class="hljs-keyword">else</span> &#123;<br>               winMap.put(sValues[right], <span class="hljs-number">1</span>);<br>               distance++;<br>           &#125;<br>           <span class="hljs-keyword">if</span> (distance &lt; t.length()) &#123;<br>               right++;<br>               <span class="hljs-keyword">continue</span>;<br>           &#125;<br>           <span class="hljs-comment">// 判断distance,等于t串长度的时候，left开始左移</span><br>           <span class="hljs-keyword">while</span> (distance == t.length()) &#123;<br>               <span class="hljs-keyword">if</span> (winMap.containsKey(sValues[left])) &#123;<br>                   <span class="hljs-keyword">if</span> (winMap.get(sValues[left]) &lt;= tMap.get(sValues[left])) &#123;<br>                       distance--;<br>                   &#125;<br>                   winMap.put(sValues[left], winMap.get(sValues[left]) - <span class="hljs-number">1</span>);<br>               &#125;<br>               left++;<br>           &#125;<br>           <span class="hljs-comment">// 最终，left为满足条件的左边界的下一个</span><br>           <span class="hljs-keyword">if</span> (right - left + <span class="hljs-number">2</span> &lt; minLength) &#123;<br>               minBegin = left - <span class="hljs-number">1</span>;<br>               minLength = right - left + <span class="hljs-number">2</span>;<br>           &#125;<br>           right++;<br>       &#125;<br>       <span class="hljs-keyword">if</span> (minLength == Integer.MAX_VALUE) &#123;<br>           <span class="hljs-keyword">return</span> <span class="hljs-string">&quot;&quot;</span>;<br>       &#125;<br>       <span class="hljs-keyword">return</span> s.substring(minBegin, minBegin + minLength);<br>   &#125;<br></code></pre></td></tr></table></figure></li>
<li>复杂度分析<ul>
<li>时间复杂度O(N+M)</li>
<li>空间复杂度O(N+M)</li>
</ul>
</li>
</ul>
<h2 id="下个路口见"><a href="#下个路口见" class="headerlink" title="下个路口见"></a>下个路口见</h2><p>HOT100依然在继续，写在下一篇文章中。<a target="_blank" rel="noopener" href="http://blog.zwboy.cn/suan-fa/leetcode/leetcode-hot-100-shua-ti-31-40.html">传送门</a></p>

                
              </div>
            
            <hr/>
            <div>
              <div class="post-metas my-3">
  
    <div class="post-meta mr-3 d-flex align-items-center">
      <i class="iconfont icon-category"></i>
      

<span class="category-chains">
  
  
    
      <span class="category-chain">
        
  <a href="/categories/%E7%AE%97%E6%B3%95/" class="category-chain-item">算法</a>
  
  
    <span>></span>
    
  <a href="/categories/%E7%AE%97%E6%B3%95/LeetCode/" class="category-chain-item">LeetCode</a>
  
  

  

      </span>
    
  
</span>

    </div>
  
  
    <div class="post-meta">
      <i class="iconfont icon-tags"></i>
      
        <a href="/tags/LeetCode/" class="print-no-link">#LeetCode</a>
      
        <a href="/tags/%E7%AE%97%E6%B3%95/" class="print-no-link">#算法</a>
      
    </div>
  
</div>


              
  

  <div class="license-box my-3">
    <div class="license-title">
      <div>LeetCode Hot 100 刷题 [21-30]</div>
      <div>http://example.com/2022/07/28/LeetCode-Hot-100-刷题-21-30/</div>
    </div>
    <div class="license-meta">
      
        <div class="license-meta-item">
          <div>作者</div>
          <div>John Doe</div>
        </div>
      
      
        <div class="license-meta-item license-meta-date">
          <div>发布于</div>
          <div>2022年7月28日</div>
        </div>
      
      
      
        <div class="license-meta-item">
          <div>许可协议</div>
          <div>
            
              
              
                <a class="print-no-link" target="_blank" href="https://creativecommons.org/licenses/by/4.0/">
                  <span class="hint--top hint--rounded" aria-label="BY - 署名">
                    <i class="iconfont icon-cc-by"></i>
                  </span>
                </a>
              
            
          </div>
        </div>
      
    </div>
    <div class="license-icon iconfont"></div>
  </div>



              
                <div class="post-prevnext my-3">
                  <article class="post-prev col-6">
                    
                    
                      <a href="/2022/08/02/LeetCode-Hot-100-%E5%88%B7%E9%A2%98-31-40/" title="LeetCode Hot 100 刷题 [31-40]">
                        <i class="iconfont icon-arrowleft"></i>
                        <span class="hidden-mobile">LeetCode Hot 100 刷题 [31-40]</span>
                        <span class="visible-mobile">上一篇</span>
                      </a>
                    
                  </article>
                  <article class="post-next col-6">
                    
                    
                      <a href="/2022/07/23/LeetCode-Hot-100-%E5%88%B7%E9%A2%98-11-20/" title="LeetCode Hot 100 刷题 [11-20]">
                        <span class="hidden-mobile">LeetCode Hot 100 刷题 [11-20]</span>
                        <span class="visible-mobile">下一篇</span>
                        <i class="iconfont icon-arrowright"></i>
                      </a>
                    
                  </article>
                </div>
              
            </div>

            
          </article>
        </div>
      </div>
    </div>

    <div class="side-col d-none d-lg-block col-lg-2">
      
  <aside class="sidebar" style="margin-left: -1rem">
    <div id="toc">
  <p class="toc-header">
    <i class="iconfont icon-list"></i>
    <span>目录</span>
  </p>
  <div class="toc-body" id="toc-body"></div>
</div>



  </aside>


    </div>
  </div>
</div>





  



  



  



  



  







    

    
      <a id="scroll-top-button" aria-label="TOP" href="#" role="button">
        <i class="iconfont icon-arrowup" aria-hidden="true"></i>
      </a>
    

    
      <div class="modal fade" id="modalSearch" tabindex="-1" role="dialog" aria-labelledby="ModalLabel"
     aria-hidden="true">
  <div class="modal-dialog modal-dialog-scrollable modal-lg" role="document">
    <div class="modal-content">
      <div class="modal-header text-center">
        <h4 class="modal-title w-100 font-weight-bold">搜索</h4>
        <button type="button" id="local-search-close" class="close" data-dismiss="modal" aria-label="Close">
          <span aria-hidden="true">&times;</span>
        </button>
      </div>
      <div class="modal-body mx-3">
        <div class="md-form mb-5">
          <input type="text" id="local-search-input" class="form-control validate">
          <label data-error="x" data-success="v" for="local-search-input">关键词</label>
        </div>
        <div class="list-group" id="local-search-result"></div>
      </div>
    </div>
  </div>
</div>

    

    
  </main>

  <footer>
    <div class="footer-inner">
  
    <div class="footer-content">
       <a href="https://hexo.io" target="_blank" rel="nofollow noopener"><span>Hexo</span></a> <i class="iconfont icon-love"></i> <a href="https://github.com/fluid-dev/hexo-theme-fluid" target="_blank" rel="nofollow noopener"><span>Fluid</span></a> 
    </div>
  
  
  
</div>

  </footer>

  <!-- Scripts -->
  
  <script  src="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.js" ></script>
  <link  rel="stylesheet" href="https://lib.baomitu.com/nprogress/0.2.0/nprogress.min.css" />

  <script>
    NProgress.configure({"showSpinner":false,"trickleSpeed":100})
    NProgress.start()
    window.addEventListener('load', function() {
      NProgress.done();
    })
  </script>


<script  src="https://lib.baomitu.com/jquery/3.6.4/jquery.min.js" ></script>
<script  src="https://lib.baomitu.com/twitter-bootstrap/4.6.1/js/bootstrap.min.js" ></script>
<script  src="/js/events.js" ></script>
<script  src="/js/plugins.js" ></script>


  <script  src="https://lib.baomitu.com/typed.js/2.0.12/typed.min.js" ></script>
  <script>
    (function (window, document) {
      var typing = Fluid.plugins.typing;
      var subtitle = document.getElementById('subtitle');
      if (!subtitle || !typing) {
        return;
      }
      var text = subtitle.getAttribute('data-typed-text');
      
        typing(text);
      
    })(window, document);
  </script>




  
    <script  src="/js/img-lazyload.js" ></script>
  




  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/tocbot/4.20.1/tocbot.min.js', function() {
    var toc = jQuery('#toc');
    if (toc.length === 0 || !window.tocbot) { return; }
    var boardCtn = jQuery('#board-ctn');
    var boardTop = boardCtn.offset().top;

    window.tocbot.init(Object.assign({
      tocSelector     : '#toc-body',
      contentSelector : '.markdown-body',
      linkClass       : 'tocbot-link',
      activeLinkClass : 'tocbot-active-link',
      listClass       : 'tocbot-list',
      isCollapsedClass: 'tocbot-is-collapsed',
      collapsibleClass: 'tocbot-is-collapsible',
      scrollSmooth    : true,
      includeTitleTags: true,
      headingsOffset  : -boardTop,
    }, CONFIG.toc));
    if (toc.find('.toc-list-item').length > 0) {
      toc.css('visibility', 'visible');
    }

    Fluid.events.registerRefreshCallback(function() {
      if ('tocbot' in window) {
        tocbot.refresh();
        var toc = jQuery('#toc');
        if (toc.length === 0 || !tocbot) {
          return;
        }
        if (toc.find('.toc-list-item').length > 0) {
          toc.css('visibility', 'visible');
        }
      }
    });
  });
</script>


  <script src=https://lib.baomitu.com/clipboard.js/2.0.11/clipboard.min.js></script>

  <script>Fluid.plugins.codeWidget();</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/anchor-js/5.0.0/anchor.min.js', function() {
    window.anchors.options = {
      placement: CONFIG.anchorjs.placement,
      visible  : CONFIG.anchorjs.visible
    };
    if (CONFIG.anchorjs.icon) {
      window.anchors.options.icon = CONFIG.anchorjs.icon;
    }
    var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
    var res = [];
    for (var item of el) {
      res.push('.markdown-body > ' + item.trim());
    }
    if (CONFIG.anchorjs.placement === 'left') {
      window.anchors.options.class = 'anchorjs-link-left';
    }
    window.anchors.add(res.join(', '));

    Fluid.events.registerRefreshCallback(function() {
      if ('anchors' in window) {
        anchors.removeAll();
        var el = (CONFIG.anchorjs.element || 'h1,h2,h3,h4,h5,h6').split(',');
        var res = [];
        for (var item of el) {
          res.push('.markdown-body > ' + item.trim());
        }
        if (CONFIG.anchorjs.placement === 'left') {
          anchors.options.class = 'anchorjs-link-left';
        }
        anchors.add(res.join(', '));
      }
    });
  });
</script>


  
<script>
  Fluid.utils.createScript('https://lib.baomitu.com/fancybox/3.5.7/jquery.fancybox.min.js', function() {
    Fluid.plugins.fancyBox();
  });
</script>


  <script>Fluid.plugins.imageCaption();</script>

  <script  src="/js/local-search.js" ></script>





<!-- 主题的启动项，将它保持在最底部 -->
<!-- the boot of the theme, keep it at the bottom -->
<script  src="/js/boot.js" ></script>


  

  <noscript>
    <div class="noscript-warning">博客在允许 JavaScript 运行的环境下浏览效果更佳</div>
  </noscript>
</body>
</html>
